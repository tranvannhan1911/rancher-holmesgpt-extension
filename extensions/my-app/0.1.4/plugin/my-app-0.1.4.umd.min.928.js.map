{"version":3,"file":"my-app-0.1.4.umd.min.928.js","mappings":"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","sources":["webpack://my-app-0.1.4/../../node_modules/vue-router/dist/vue-router.prod.cjs","webpack://my-app-0.1.4/../../node_modules/vue-router/index.js"],"sourcesContent":["/*!\n  * vue-router v4.5.0\n  * (c) 2024 Eduardo San Martin Morote\n  * @license MIT\n  */\n'use strict';\n\nvar vue = require('vue');\n\nconst isBrowser = typeof document !== 'undefined';\n\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n * @internal\n *\n * @param component\n */\nfunction isRouteComponent(component) {\n    return (typeof component === 'object' ||\n        'displayName' in component ||\n        'props' in component ||\n        '__vccOpts' in component);\n}\nfunction isESModule(obj) {\n    return (obj.__esModule ||\n        obj[Symbol.toStringTag] === 'Module' ||\n        // support CF with dynamic imports that do not\n        // add the Module string tag\n        (obj.default && isRouteComponent(obj.default)));\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n    const newParams = {};\n    for (const key in params) {\n        const value = params[key];\n        newParams[key] = isArray(value)\n            ? value.map(fn)\n            : fn(value);\n    }\n    return newParams;\n}\nconst noop = () => { };\n/**\n * Typesafe alternative to Array.isArray\n * https://github.com/microsoft/TypeScript/pull/48228\n */\nconst isArray = Array.isArray;\n\n/**\n * Encoding Rules (␣ = Space)\n * - Path: ␣ \" < > # ? { }\n * - Query: ␣ \" < > # & =\n * - Hash: ␣ \" < > `\n *\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n * defines some extra characters to be encoded. Most browsers do not encode them\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n * also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)\n * plus `-._~`. This extra safety should be applied to query by patching the\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\n * encoded everywhere because some browsers like FF encode it when directly\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\n * seems to be less flexible than not doing so and I can't find out the legacy\n * systems requiring this for regular requests like text/html. In the standard,\n * the encoding of the plus character is only mentioned for\n * application/x-www-form-urlencoded\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n * leave the plus character as is in queries. To be more flexible, we allow the\n * plus character on the query, but it can also be manually encoded by the user.\n *\n * Resources:\n * - https://url.spec.whatwg.org/#urlencoded-parsing\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\n * Encode characters that need to be encoded on the path, search and hash\n * sections of the URL.\n *\n * @internal\n * @param text - string to encode\n * @returns encoded string\n */\nfunction commonEncode(text) {\n    return encodeURI('' + text)\n        .replace(ENC_PIPE_RE, '|')\n        .replace(ENC_BRACKET_OPEN_RE, '[')\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\n * Encode characters that need to be encoded on the hash section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeHash(text) {\n    return commonEncode(text)\n        .replace(ENC_CURLY_OPEN_RE, '{')\n        .replace(ENC_CURLY_CLOSE_RE, '}')\n        .replace(ENC_CARET_RE, '^');\n}\n/**\n * Encode characters that need to be encoded query values on the query\n * section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeQueryValue(text) {\n    return (commonEncode(text)\n        // Encode the space as +, encode the + to differentiate it from the space\n        .replace(PLUS_RE, '%2B')\n        .replace(ENC_SPACE_RE, '+')\n        .replace(HASH_RE, '%23')\n        .replace(AMPERSAND_RE, '%26')\n        .replace(ENC_BACKTICK_RE, '`')\n        .replace(ENC_CURLY_OPEN_RE, '{')\n        .replace(ENC_CURLY_CLOSE_RE, '}')\n        .replace(ENC_CARET_RE, '^'));\n}\n/**\n * Like `encodeQueryValue` but also encodes the `=` character.\n *\n * @param text - string to encode\n */\nfunction encodeQueryKey(text) {\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodePath(text) {\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL as a\n * param. This function encodes everything {@link encodePath} does plus the\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n * string instead.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeParam(text) {\n    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\n * Decode text using `decodeURIComponent`. Returns the original text if it\n * fails.\n *\n * @param text - string to decode\n * @returns decoded string\n */\nfunction decode(text) {\n    try {\n        return decodeURIComponent('' + text);\n    }\n    catch (err) {\n    }\n    return '' + text;\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\n/**\n * Transforms a URI into a normalized history location\n *\n * @param parseQuery\n * @param location - URI to normalize\n * @param currentLocation - current absolute location. Allows resolving relative\n * paths. Must start with `/`. Defaults to `/`\n * @returns a normalized history location\n */\nfunction parseURL(parseQuery, location, currentLocation = '/') {\n    let path, query = {}, searchString = '', hash = '';\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\n    // TODO: move to new URL()\n    const hashPos = location.indexOf('#');\n    let searchPos = location.indexOf('?');\n    // the hash appears before the search, so it's not part of the search string\n    if (hashPos < searchPos && hashPos >= 0) {\n        searchPos = -1;\n    }\n    if (searchPos > -1) {\n        path = location.slice(0, searchPos);\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n        query = parseQuery(searchString);\n    }\n    if (hashPos > -1) {\n        path = path || location.slice(0, hashPos);\n        // keep the # character\n        hash = location.slice(hashPos, location.length);\n    }\n    // no search and no query\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\n    // empty path means a relative query or hash `?foo=f`, `#thing`\n    return {\n        fullPath: path + (searchString && '?') + searchString + hash,\n        path,\n        query,\n        hash: decode(hash),\n    };\n}\n/**\n * Stringifies a URL object\n *\n * @param stringifyQuery\n * @param location\n */\nfunction stringifyURL(stringifyQuery, location) {\n    const query = location.query ? stringifyQuery(location.query) : '';\n    return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\n * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.\n *\n * @param pathname - location.pathname\n * @param base - base to strip off\n */\nfunction stripBase(pathname, base) {\n    // no base or base is not found at the beginning\n    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n        return pathname;\n    return pathname.slice(base.length) || '/';\n}\n/**\n * Checks if two RouteLocation are equal. This means that both locations are\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\n * parameters and `hash` are the same\n *\n * @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.\n * @param a - first {@link RouteLocation}\n * @param b - second {@link RouteLocation}\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n    const aLastIndex = a.matched.length - 1;\n    const bLastIndex = b.matched.length - 1;\n    return (aLastIndex > -1 &&\n        aLastIndex === bLastIndex &&\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\n        isSameRouteLocationParams(a.params, b.params) &&\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\n        a.hash === b.hash);\n}\n/**\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\n * considered equal to the `RouteRecord` they are aliasing.\n *\n * @param a - first {@link RouteRecord}\n * @param b - second {@link RouteRecord}\n */\nfunction isSameRouteRecord(a, b) {\n    // since the original record has an undefined value for aliasOf\n    // but all aliases point to the original record, this will always compare\n    // the original record\n    return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n    if (Object.keys(a).length !== Object.keys(b).length)\n        return false;\n    for (const key in a) {\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\n            return false;\n    }\n    return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n    return isArray(a)\n        ? isEquivalentArray(a, b)\n        : isArray(b)\n            ? isEquivalentArray(b, a)\n            : a === b;\n}\n/**\n * Check if two arrays are the same or if an array with one single entry is the\n * same as another primitive value. Used to check query and parameters\n *\n * @param a - array of values\n * @param b - array of values or a single value\n */\nfunction isEquivalentArray(a, b) {\n    return isArray(b)\n        ? a.length === b.length && a.every((value, i) => value === b[i])\n        : a.length === 1 && a[0] === b;\n}\n/**\n * Resolves a relative path that starts with `.`.\n *\n * @param to - path location we are resolving\n * @param from - currentLocation.path, should start with `/`\n */\nfunction resolveRelativePath(to, from) {\n    if (to.startsWith('/'))\n        return to;\n    if (!to)\n        return from;\n    const fromSegments = from.split('/');\n    const toSegments = to.split('/');\n    const lastToSegment = toSegments[toSegments.length - 1];\n    // make . and ./ the same (../ === .., ../../ === ../..)\n    // this is the same behavior as new URL()\n    if (lastToSegment === '..' || lastToSegment === '.') {\n        toSegments.push('');\n    }\n    let position = fromSegments.length - 1;\n    let toPosition;\n    let segment;\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n        segment = toSegments[toPosition];\n        // we stay on the same position\n        if (segment === '.')\n            continue;\n        // go up in the from array\n        if (segment === '..') {\n            // we can't go below zero, but we still need to increment toPosition\n            if (position > 1)\n                position--;\n            // continue\n        }\n        // we reached a non-relative path, we stop here\n        else\n            break;\n    }\n    return (fromSegments.slice(0, position).join('/') +\n        '/' +\n        toSegments.slice(toPosition).join('/'));\n}\n/**\n * Initial route location where the router is. Can be used in navigation guards\n * to differentiate the initial navigation.\n *\n * @example\n * ```js\n * import { START_LOCATION } from 'vue-router'\n *\n * router.beforeEach((to, from) => {\n *   if (from === START_LOCATION) {\n *     // initial navigation\n *   }\n * })\n * ```\n */\nconst START_LOCATION_NORMALIZED = {\n    path: '/',\n    // TODO: could we use a symbol in the future?\n    name: undefined,\n    params: {},\n    query: {},\n    hash: '',\n    fullPath: '/',\n    matched: [],\n    meta: {},\n    redirectedFrom: undefined,\n};\n\nvar NavigationType;\n(function (NavigationType) {\n    NavigationType[\"pop\"] = \"pop\";\n    NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n    NavigationDirection[\"back\"] = \"back\";\n    NavigationDirection[\"forward\"] = \"forward\";\n    NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\n * Starting location for Histories\n */\nconst START = '';\n// Generic utils\n/**\n * Normalizes a base by removing any trailing slash and reading the base tag if\n * present.\n *\n * @param base - base to normalize\n */\nfunction normalizeBase(base) {\n    if (!base) {\n        if (isBrowser) {\n            // respect <base> tag\n            const baseEl = document.querySelector('base');\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\n            // strip full URL origin\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n        }\n        else {\n            base = '/';\n        }\n    }\n    // ensure leading slash when it was removed by the regex above avoid leading\n    // slash with hash because the file could be read from the disk like file://\n    // and the leading slash would cause problems\n    if (base[0] !== '/' && base[0] !== '#')\n        base = '/' + base;\n    // remove the trailing slash so all other method can just do `base + fullPath`\n    // to build an href\n    return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n    return base.replace(BEFORE_HASH_RE, '#') + location;\n}\n\nfunction getElementPosition(el, offset) {\n    const docRect = document.documentElement.getBoundingClientRect();\n    const elRect = el.getBoundingClientRect();\n    return {\n        behavior: offset.behavior,\n        left: elRect.left - docRect.left - (offset.left || 0),\n        top: elRect.top - docRect.top - (offset.top || 0),\n    };\n}\nconst computeScrollPosition = () => ({\n    left: window.scrollX,\n    top: window.scrollY,\n});\nfunction scrollToPosition(position) {\n    let scrollToOptions;\n    if ('el' in position) {\n        const positionEl = position.el;\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n        const el = typeof positionEl === 'string'\n            ? isIdSelector\n                ? document.getElementById(positionEl.slice(1))\n                : document.querySelector(positionEl)\n            : positionEl;\n        if (!el) {\n            return;\n        }\n        scrollToOptions = getElementPosition(el, position);\n    }\n    else {\n        scrollToOptions = position;\n    }\n    if ('scrollBehavior' in document.documentElement.style)\n        window.scrollTo(scrollToOptions);\n    else {\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);\n    }\n}\nfunction getScrollKey(path, delta) {\n    const position = history.state ? history.state.position - delta : -1;\n    return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n    scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n    const scroll = scrollPositions.get(key);\n    // consume it so it's not used again\n    scrollPositions.delete(key);\n    return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\n * ScrollBehavior instance used by the router to compute and restore the scroll\n * position when navigating.\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\n * Creates a normalized history location from a window.location object\n * @param base - The base path\n * @param location - The window.location object\n */\nfunction createCurrentLocation(base, location) {\n    const { pathname, search, hash } = location;\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n    const hashPos = base.indexOf('#');\n    if (hashPos > -1) {\n        let slicePos = hash.includes(base.slice(hashPos))\n            ? base.slice(hashPos).length\n            : 1;\n        let pathFromHash = hash.slice(slicePos);\n        // prepend the starting slash to hash so the url starts with /#\n        if (pathFromHash[0] !== '/')\n            pathFromHash = '/' + pathFromHash;\n        return stripBase(pathFromHash, '');\n    }\n    const path = stripBase(pathname, base);\n    return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n    let listeners = [];\n    let teardowns = [];\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\n    // can trigger twice\n    let pauseState = null;\n    const popStateHandler = ({ state, }) => {\n        const to = createCurrentLocation(base, location);\n        const from = currentLocation.value;\n        const fromState = historyState.value;\n        let delta = 0;\n        if (state) {\n            currentLocation.value = to;\n            historyState.value = state;\n            // ignore the popstate and reset the pauseState\n            if (pauseState && pauseState === from) {\n                pauseState = null;\n                return;\n            }\n            delta = fromState ? state.position - fromState.position : 0;\n        }\n        else {\n            replace(to);\n        }\n        // Here we could also revert the navigation by calling history.go(-delta)\n        // this listener will have to be adapted to not trigger again and to wait for the url\n        // to be updated before triggering the listeners. Some kind of validation function would also\n        // need to be passed to the listeners so the navigation can be accepted\n        // call all listeners\n        listeners.forEach(listener => {\n            listener(currentLocation.value, from, {\n                delta,\n                type: NavigationType.pop,\n                direction: delta\n                    ? delta > 0\n                        ? NavigationDirection.forward\n                        : NavigationDirection.back\n                    : NavigationDirection.unknown,\n            });\n        });\n    };\n    function pauseListeners() {\n        pauseState = currentLocation.value;\n    }\n    function listen(callback) {\n        // set up the listener and prepare teardown callbacks\n        listeners.push(callback);\n        const teardown = () => {\n            const index = listeners.indexOf(callback);\n            if (index > -1)\n                listeners.splice(index, 1);\n        };\n        teardowns.push(teardown);\n        return teardown;\n    }\n    function beforeUnloadListener() {\n        const { history } = window;\n        if (!history.state)\n            return;\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\n    }\n    function destroy() {\n        for (const teardown of teardowns)\n            teardown();\n        teardowns = [];\n        window.removeEventListener('popstate', popStateHandler);\n        window.removeEventListener('beforeunload', beforeUnloadListener);\n    }\n    // set up the listeners and prepare teardown callbacks\n    window.addEventListener('popstate', popStateHandler);\n    // TODO: could we use 'pagehide' or 'visibilitychange' instead?\n    // https://developer.chrome.com/blog/page-lifecycle-api/\n    window.addEventListener('beforeunload', beforeUnloadListener, {\n        passive: true,\n    });\n    return {\n        pauseListeners,\n        listen,\n        destroy,\n    };\n}\n/**\n * Creates a state object\n */\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n    return {\n        back,\n        current,\n        forward,\n        replaced,\n        position: window.history.length,\n        scroll: computeScroll ? computeScrollPosition() : null,\n    };\n}\nfunction useHistoryStateNavigation(base) {\n    const { history, location } = window;\n    // private variables\n    const currentLocation = {\n        value: createCurrentLocation(base, location),\n    };\n    const historyState = { value: history.state };\n    // build current history entry as this is a fresh navigation\n    if (!historyState.value) {\n        changeLocation(currentLocation.value, {\n            back: null,\n            current: currentLocation.value,\n            forward: null,\n            // the length is off by one, we need to decrease it\n            position: history.length - 1,\n            replaced: true,\n            // don't add a scroll as the user may have an anchor, and we want\n            // scrollBehavior to be triggered without a saved position\n            scroll: null,\n        }, true);\n    }\n    function changeLocation(to, state, replace) {\n        /**\n         * if a base tag is provided, and we are on a normal domain, we have to\n         * respect the provided `base` attribute because pushState() will use it and\n         * potentially erase anything before the `#` like at\n         * https://github.com/vuejs/router/issues/685 where a base of\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\n         * base tag we can just use everything after the `#`.\n         */\n        const hashIndex = base.indexOf('#');\n        const url = hashIndex > -1\n            ? (location.host && document.querySelector('base')\n                ? base\n                : base.slice(hashIndex)) + to\n            : createBaseLocation() + base + to;\n        try {\n            // BROWSER QUIRK\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\n            historyState.value = state;\n        }\n        catch (err) {\n            {\n                console.error(err);\n            }\n            // Force the navigation, this also resets the call count\n            location[replace ? 'replace' : 'assign'](url);\n        }\n    }\n    function replace(to, data) {\n        const state = assign({}, history.state, buildState(historyState.value.back, \n        // keep back and forward entries but override current position\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\n        changeLocation(to, state, true);\n        currentLocation.value = to;\n    }\n    function push(to, data) {\n        // Add to current entry the information of where we are going\n        // as well as saving the current position\n        const currentState = assign({}, \n        // use current history state to gracefully handle a wrong call to\n        // history.replaceState\n        // https://github.com/vuejs/router/issues/366\n        historyState.value, history.state, {\n            forward: to,\n            scroll: computeScrollPosition(),\n        });\n        changeLocation(currentState.current, currentState, true);\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\n        changeLocation(to, state, false);\n        currentLocation.value = to;\n    }\n    return {\n        location: currentLocation,\n        state: historyState,\n        push,\n        replace,\n    };\n}\n/**\n * Creates an HTML5 history. Most common history for single page applications.\n *\n * @param base -\n */\nfunction createWebHistory(base) {\n    base = normalizeBase(base);\n    const historyNavigation = useHistoryStateNavigation(base);\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n    function go(delta, triggerListeners = true) {\n        if (!triggerListeners)\n            historyListeners.pauseListeners();\n        history.go(delta);\n    }\n    const routerHistory = assign({\n        // it's overridden right after\n        location: '',\n        base,\n        go,\n        createHref: createHref.bind(null, base),\n    }, historyNavigation, historyListeners);\n    Object.defineProperty(routerHistory, 'location', {\n        enumerable: true,\n        get: () => historyNavigation.location.value,\n    });\n    Object.defineProperty(routerHistory, 'state', {\n        enumerable: true,\n        get: () => historyNavigation.state.value,\n    });\n    return routerHistory;\n}\n\n/**\n * Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n *\n * @param base - Base applied to all urls, defaults to '/'\n * @returns a history object that can be passed to the router constructor\n */\nfunction createMemoryHistory(base = '') {\n    let listeners = [];\n    let queue = [START];\n    let position = 0;\n    base = normalizeBase(base);\n    function setLocation(location) {\n        position++;\n        if (position !== queue.length) {\n            // we are in the middle, we remove everything from here in the queue\n            queue.splice(position);\n        }\n        queue.push(location);\n    }\n    function triggerListeners(to, from, { direction, delta }) {\n        const info = {\n            direction,\n            delta,\n            type: NavigationType.pop,\n        };\n        for (const callback of listeners) {\n            callback(to, from, info);\n        }\n    }\n    const routerHistory = {\n        // rewritten by Object.defineProperty\n        location: START,\n        // TODO: should be kept in queue\n        state: {},\n        base,\n        createHref: createHref.bind(null, base),\n        replace(to) {\n            // remove current entry and decrement position\n            queue.splice(position--, 1);\n            setLocation(to);\n        },\n        push(to, data) {\n            setLocation(to);\n        },\n        listen(callback) {\n            listeners.push(callback);\n            return () => {\n                const index = listeners.indexOf(callback);\n                if (index > -1)\n                    listeners.splice(index, 1);\n            };\n        },\n        destroy() {\n            listeners = [];\n            queue = [START];\n            position = 0;\n        },\n        go(delta, shouldTrigger = true) {\n            const from = this.location;\n            const direction = \n            // we are considering delta === 0 going forward, but in abstract mode\n            // using 0 for the delta doesn't make sense like it does in html5 where\n            // it reloads the page\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\n            if (shouldTrigger) {\n                triggerListeners(this.location, from, {\n                    direction,\n                    delta,\n                });\n            }\n        },\n    };\n    Object.defineProperty(routerHistory, 'location', {\n        enumerable: true,\n        get: () => queue[position],\n    });\n    return routerHistory;\n}\n\n/**\n * Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\n * handle any URL is not possible.\n *\n * @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\n * in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\n * calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything\n * after the `#`).\n *\n * @example\n * ```js\n * // at https://example.com/folder\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n * // you should avoid doing this because it changes the original url and breaks copying urls\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n *\n * // at file:///usr/etc/folder/index.html\n * // for locations with no `host`, the base is ignored\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n * ```\n */\nfunction createWebHashHistory(base) {\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\n    // for `file://`, directly use the pathname and ignore the base\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\n    base = location.host ? base || location.pathname + location.search : '';\n    // allow the user to provide a `#` in the middle: `/base/#/app`\n    if (!base.includes('#'))\n        base += '#';\n    return createWebHistory(base);\n}\n\nfunction isRouteLocation(route) {\n    return typeof route === 'string' || (route && typeof route === 'object');\n}\nfunction isRouteName(name) {\n    return typeof name === 'string' || typeof name === 'symbol';\n}\n\nconst NavigationFailureSymbol = Symbol('');\n/**\n * Enumeration with all possible types for navigation failures. Can be passed to\n * {@link isNavigationFailure} to check for specific failures.\n */\nexports.NavigationFailureType = void 0;\n(function (NavigationFailureType) {\n    /**\n     * An aborted navigation is a navigation that failed because a navigation\n     * guard returned `false` or called `next(false)`\n     */\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n    /**\n     * A cancelled navigation is a navigation that failed because a more recent\n     * navigation finished started (not necessarily finished).\n     */\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n    /**\n     * A duplicated navigation is a navigation that failed because it was\n     * initiated while already being at the exact same location.\n     */\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(exports.NavigationFailureType || (exports.NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n    [1 /* ErrorTypes.MATCHER_NOT_FOUND */]({ location, currentLocation }) {\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\n            : ''}`;\n    },\n    [2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n    },\n    [4 /* ErrorTypes.NAVIGATION_ABORTED */]({ from, to }) {\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n    },\n    [8 /* ErrorTypes.NAVIGATION_CANCELLED */]({ from, to }) {\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n    },\n    [16 /* ErrorTypes.NAVIGATION_DUPLICATED */]({ from, to }) {\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n    },\n};\n/**\n * Creates a typed NavigationFailure object.\n * @internal\n * @param type - NavigationFailureType\n * @param params - { from, to }\n */\nfunction createRouterError(type, params) {\n    // keep full error messages in cjs versions\n    {\n        return assign(new Error(ErrorTypeMessages[type](params)), {\n            type,\n            [NavigationFailureSymbol]: true,\n        }, params);\n    }\n}\nfunction isNavigationFailure(error, type) {\n    return (error instanceof Error &&\n        NavigationFailureSymbol in error &&\n        (type == null || !!(error.type & type)));\n}\nconst propertiesToLog = ['params', 'query', 'hash'];\nfunction stringifyRoute(to) {\n    if (typeof to === 'string')\n        return to;\n    if (to.path != null)\n        return to.path;\n    const location = {};\n    for (const key of propertiesToLog) {\n        if (key in to)\n            location[key] = to[key];\n    }\n    return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non-greedy everything but /\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n    sensitive: false,\n    strict: false,\n    start: true,\n    end: true,\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\n *\n * @param segments - array of segments returned by tokenizePath\n * @param extraOptions - optional options for the regexp\n * @returns a PathParser\n */\nfunction tokensToParser(segments, extraOptions) {\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\n    const score = [];\n    // the regexp as a string\n    let pattern = options.start ? '^' : '';\n    // extracted keys\n    const keys = [];\n    for (const segment of segments) {\n        // the root segment needs special treatment\n        const segmentScores = segment.length ? [] : [90 /* PathScore.Root */];\n        // allow trailing slash\n        if (options.strict && !segment.length)\n            pattern += '/';\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n            const token = segment[tokenIndex];\n            // resets the score if we are inside a sub-segment /:a-other-:b\n            let subSegmentScore = 40 /* PathScore.Segment */ +\n                (options.sensitive ? 0.25 /* PathScore.BonusCaseSensitive */ : 0);\n            if (token.type === 0 /* TokenType.Static */) {\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    pattern += '/';\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n                subSegmentScore += 40 /* PathScore.Static */;\n            }\n            else if (token.type === 1 /* TokenType.Param */) {\n                const { value, repeatable, optional, regexp } = token;\n                keys.push({\n                    name: value,\n                    repeatable,\n                    optional,\n                });\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\n                // the user provided a custom regexp /:id(\\\\d+)\n                if (re !== BASE_PARAM_PATTERN) {\n                    subSegmentScore += 10 /* PathScore.BonusCustomRegExp */;\n                    // make sure the regexp is valid before using it\n                    try {\n                        new RegExp(`(${re})`);\n                    }\n                    catch (err) {\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\n                            err.message);\n                    }\n                }\n                // when we repeat we must take care of the repeating leading slash\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    subPattern =\n                        // avoid an optional / if there are more segments e.g. /:p?-static\n                        // or /:p?-:p2\n                        optional && segment.length < 2\n                            ? `(?:/${subPattern})`\n                            : '/' + subPattern;\n                if (optional)\n                    subPattern += '?';\n                pattern += subPattern;\n                subSegmentScore += 20 /* PathScore.Dynamic */;\n                if (optional)\n                    subSegmentScore += -8 /* PathScore.BonusOptional */;\n                if (repeatable)\n                    subSegmentScore += -20 /* PathScore.BonusRepeatable */;\n                if (re === '.*')\n                    subSegmentScore += -50 /* PathScore.BonusWildcard */;\n            }\n            segmentScores.push(subSegmentScore);\n        }\n        // an empty array like /home/ -> [[{home}], []]\n        // if (!segment.length) pattern += '/'\n        score.push(segmentScores);\n    }\n    // only apply the strict bonus to the last score\n    if (options.strict && options.end) {\n        const i = score.length - 1;\n        score[i][score[i].length - 1] += 0.7000000000000001 /* PathScore.BonusStrict */;\n    }\n    // TODO: dev only warn double trailing slash\n    if (!options.strict)\n        pattern += '/?';\n    if (options.end)\n        pattern += '$';\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n    else if (options.strict && !pattern.endsWith('/'))\n        pattern += '(?:/|$)';\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n    function parse(path) {\n        const match = path.match(re);\n        const params = {};\n        if (!match)\n            return null;\n        for (let i = 1; i < match.length; i++) {\n            const value = match[i] || '';\n            const key = keys[i - 1];\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\n        }\n        return params;\n    }\n    function stringify(params) {\n        let path = '';\n        // for optional parameters to allow to be empty\n        let avoidDuplicatedSlash = false;\n        for (const segment of segments) {\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\n                path += '/';\n            avoidDuplicatedSlash = false;\n            for (const token of segment) {\n                if (token.type === 0 /* TokenType.Static */) {\n                    path += token.value;\n                }\n                else if (token.type === 1 /* TokenType.Param */) {\n                    const { value, repeatable, optional } = token;\n                    const param = value in params ? params[value] : '';\n                    if (isArray(param) && !repeatable) {\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n                    }\n                    const text = isArray(param)\n                        ? param.join('/')\n                        : param;\n                    if (!text) {\n                        if (optional) {\n                            // if we have more than one optional param like /:a?-static we don't need to care about the optional param\n                            if (segment.length < 2) {\n                                // remove the last slash as we could be at the end\n                                if (path.endsWith('/'))\n                                    path = path.slice(0, -1);\n                                // do not append a slash on the next iteration\n                                else\n                                    avoidDuplicatedSlash = true;\n                            }\n                        }\n                        else\n                            throw new Error(`Missing required param \"${value}\"`);\n                    }\n                    path += text;\n                }\n            }\n        }\n        // avoid empty path when we have multiple optional params\n        return path || '/';\n    }\n    return {\n        re,\n        score,\n        keys,\n        parse,\n        stringify,\n    };\n}\n/**\n * Compares an array of numbers as used in PathParser.score and returns a\n * number. This function can be used to `sort` an array\n *\n * @param a - first array of numbers\n * @param b - second array of numbers\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n * should be sorted first\n */\nfunction compareScoreArray(a, b) {\n    let i = 0;\n    while (i < a.length && i < b.length) {\n        const diff = b[i] - a[i];\n        // only keep going if diff === 0\n        if (diff)\n            return diff;\n        i++;\n    }\n    // if the last subsegment was Static, the shorter segments should be sorted first\n    // otherwise sort the longest segment first\n    if (a.length < b.length) {\n        return a.length === 1 && a[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */\n            ? -1\n            : 1;\n    }\n    else if (a.length > b.length) {\n        return b.length === 1 && b[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */\n            ? 1\n            : -1;\n    }\n    return 0;\n}\n/**\n * Compare function that can be used with `sort` to sort an array of PathParser\n *\n * @param a - first PathParser\n * @param b - second PathParser\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n */\nfunction comparePathParserScore(a, b) {\n    let i = 0;\n    const aScore = a.score;\n    const bScore = b.score;\n    while (i < aScore.length && i < bScore.length) {\n        const comp = compareScoreArray(aScore[i], bScore[i]);\n        // do not return if both are equal\n        if (comp)\n            return comp;\n        i++;\n    }\n    if (Math.abs(bScore.length - aScore.length) === 1) {\n        if (isLastScoreNegative(aScore))\n            return 1;\n        if (isLastScoreNegative(bScore))\n            return -1;\n    }\n    // if a and b share the same score entries but b has more, sort b first\n    return bScore.length - aScore.length;\n    // this is the ternary version\n    // return aScore.length < bScore.length\n    //   ? 1\n    //   : aScore.length > bScore.length\n    //   ? -1\n    //   : 0\n}\n/**\n * This allows detecting splats at the end of a path: /home/:id(.*)*\n *\n * @param score - score to check\n * @returns true if the last entry is negative\n */\nfunction isLastScoreNegative(score) {\n    const last = score[score.length - 1];\n    return score.length > 0 && last[last.length - 1] < 0;\n}\n\nconst ROOT_TOKEN = {\n    type: 0 /* TokenType.Static */,\n    value: '',\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n    if (!path)\n        return [[]];\n    if (path === '/')\n        return [[ROOT_TOKEN]];\n    if (!path.startsWith('/')) {\n        throw new Error(`Invalid path \"${path}\"`);\n    }\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\n    function crash(message) {\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n    }\n    let state = 0 /* TokenizerState.Static */;\n    let previousState = state;\n    const tokens = [];\n    // the segment will always be valid because we get into the initial state\n    // with the leading /\n    let segment;\n    function finalizeSegment() {\n        if (segment)\n            tokens.push(segment);\n        segment = [];\n    }\n    // index on the path\n    let i = 0;\n    // char at index\n    let char;\n    // buffer of the value read\n    let buffer = '';\n    // custom regexp for a param\n    let customRe = '';\n    function consumeBuffer() {\n        if (!buffer)\n            return;\n        if (state === 0 /* TokenizerState.Static */) {\n            segment.push({\n                type: 0 /* TokenType.Static */,\n                value: buffer,\n            });\n        }\n        else if (state === 1 /* TokenizerState.Param */ ||\n            state === 2 /* TokenizerState.ParamRegExp */ ||\n            state === 3 /* TokenizerState.ParamRegExpEnd */) {\n            if (segment.length > 1 && (char === '*' || char === '+'))\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n            segment.push({\n                type: 1 /* TokenType.Param */,\n                value: buffer,\n                regexp: customRe,\n                repeatable: char === '*' || char === '+',\n                optional: char === '*' || char === '?',\n            });\n        }\n        else {\n            crash('Invalid state to consume buffer');\n        }\n        buffer = '';\n    }\n    function addCharToBuffer() {\n        buffer += char;\n    }\n    while (i < path.length) {\n        char = path[i++];\n        if (char === '\\\\' && state !== 2 /* TokenizerState.ParamRegExp */) {\n            previousState = state;\n            state = 4 /* TokenizerState.EscapeNext */;\n            continue;\n        }\n        switch (state) {\n            case 0 /* TokenizerState.Static */:\n                if (char === '/') {\n                    if (buffer) {\n                        consumeBuffer();\n                    }\n                    finalizeSegment();\n                }\n                else if (char === ':') {\n                    consumeBuffer();\n                    state = 1 /* TokenizerState.Param */;\n                }\n                else {\n                    addCharToBuffer();\n                }\n                break;\n            case 4 /* TokenizerState.EscapeNext */:\n                addCharToBuffer();\n                state = previousState;\n                break;\n            case 1 /* TokenizerState.Param */:\n                if (char === '(') {\n                    state = 2 /* TokenizerState.ParamRegExp */;\n                }\n                else if (VALID_PARAM_RE.test(char)) {\n                    addCharToBuffer();\n                }\n                else {\n                    consumeBuffer();\n                    state = 0 /* TokenizerState.Static */;\n                    // go back one character if we were not modifying\n                    if (char !== '*' && char !== '?' && char !== '+')\n                        i--;\n                }\n                break;\n            case 2 /* TokenizerState.ParamRegExp */:\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n                // it already works by escaping the closing )\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n                // is this really something people need since you can also write\n                // /prefix_:p()_suffix\n                if (char === ')') {\n                    // handle the escaped )\n                    if (customRe[customRe.length - 1] == '\\\\')\n                        customRe = customRe.slice(0, -1) + char;\n                    else\n                        state = 3 /* TokenizerState.ParamRegExpEnd */;\n                }\n                else {\n                    customRe += char;\n                }\n                break;\n            case 3 /* TokenizerState.ParamRegExpEnd */:\n                // same as finalizing a param\n                consumeBuffer();\n                state = 0 /* TokenizerState.Static */;\n                // go back one character if we were not modifying\n                if (char !== '*' && char !== '?' && char !== '+')\n                    i--;\n                customRe = '';\n                break;\n            default:\n                crash('Unknown state');\n                break;\n        }\n    }\n    if (state === 2 /* TokenizerState.ParamRegExp */)\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n    consumeBuffer();\n    finalizeSegment();\n    // tokenCache.set(path, tokens)\n    return tokens;\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\n    const parser = tokensToParser(tokenizePath(record.path), options);\n    const matcher = assign(parser, {\n        record,\n        parent,\n        // these needs to be populated by the parent\n        children: [],\n        alias: [],\n    });\n    if (parent) {\n        // both are aliases or both are not aliases\n        // we don't want to mix them because the order is used when\n        // passing originalRecord in Matcher.addRoute\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\n            parent.children.push(matcher);\n    }\n    return matcher;\n}\n\n/**\n * Creates a Router Matcher.\n *\n * @internal\n * @param routes - array of initial routes\n * @param globalOptions - global route options\n */\nfunction createRouterMatcher(routes, globalOptions) {\n    // normalized ordered array of matchers\n    const matchers = [];\n    const matcherMap = new Map();\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\n    function getRecordMatcher(name) {\n        return matcherMap.get(name);\n    }\n    function addRoute(record, parent, originalRecord) {\n        // used later on to remove by name\n        const isRootAdd = !originalRecord;\n        const mainNormalizedRecord = normalizeRouteRecord(record);\n        // we might be the child of an alias\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n        const options = mergeOptions(globalOptions, record);\n        // generate an array of records to correctly handle aliases\n        const normalizedRecords = [mainNormalizedRecord];\n        if ('alias' in record) {\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n            for (const alias of aliases) {\n                normalizedRecords.push(\n                // we need to normalize again to ensure the `mods` property\n                // being non enumerable\n                normalizeRouteRecord(assign({}, mainNormalizedRecord, {\n                    // this allows us to hold a copy of the `components` option\n                    // so that async components cache is hold on the original record\n                    components: originalRecord\n                        ? originalRecord.record.components\n                        : mainNormalizedRecord.components,\n                    path: alias,\n                    // we might be the child of an alias\n                    aliasOf: originalRecord\n                        ? originalRecord.record\n                        : mainNormalizedRecord,\n                    // the aliases are always of the same kind as the original since they\n                    // are defined on the same record\n                })));\n            }\n        }\n        let matcher;\n        let originalMatcher;\n        for (const normalizedRecord of normalizedRecords) {\n            const { path } = normalizedRecord;\n            // Build up the path for nested routes if the child isn't an absolute\n            // route. Only add the / delimiter if the child path isn't empty and if the\n            // parent path doesn't have a trailing slash\n            if (parent && path[0] !== '/') {\n                const parentPath = parent.record.path;\n                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n                normalizedRecord.path =\n                    parent.record.path + (path && connectingSlash + path);\n            }\n            // create the object beforehand, so it can be passed to children\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n            // if we are an alias we must tell the original record that we exist,\n            // so we can be removed\n            if (originalRecord) {\n                originalRecord.alias.push(matcher);\n            }\n            else {\n                // otherwise, the first record is the original and others are aliases\n                originalMatcher = originalMatcher || matcher;\n                if (originalMatcher !== matcher)\n                    originalMatcher.alias.push(matcher);\n                // remove the route if named and only for the top record (avoid in nested calls)\n                // this works because the original record is the first one\n                if (isRootAdd && record.name && !isAliasRecord(matcher)) {\n                    removeRoute(record.name);\n                }\n            }\n            // Avoid adding a record that doesn't display anything. This allows passing through records without a component to\n            // not be reached and pass through the catch all route\n            if (isMatchable(matcher)) {\n                insertMatcher(matcher);\n            }\n            if (mainNormalizedRecord.children) {\n                const children = mainNormalizedRecord.children;\n                for (let i = 0; i < children.length; i++) {\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n                }\n            }\n            // if there was no original record, then the first one was not an alias and all\n            // other aliases (if any) need to reference this record when adding children\n            originalRecord = originalRecord || matcher;\n            // TODO: add normalized records for more flexibility\n            // if (parent && isAliasRecord(originalRecord)) {\n            //   parent.children.push(originalRecord)\n            // }\n        }\n        return originalMatcher\n            ? () => {\n                // since other matchers are aliases, they should be removed by the original matcher\n                removeRoute(originalMatcher);\n            }\n            : noop;\n    }\n    function removeRoute(matcherRef) {\n        if (isRouteName(matcherRef)) {\n            const matcher = matcherMap.get(matcherRef);\n            if (matcher) {\n                matcherMap.delete(matcherRef);\n                matchers.splice(matchers.indexOf(matcher), 1);\n                matcher.children.forEach(removeRoute);\n                matcher.alias.forEach(removeRoute);\n            }\n        }\n        else {\n            const index = matchers.indexOf(matcherRef);\n            if (index > -1) {\n                matchers.splice(index, 1);\n                if (matcherRef.record.name)\n                    matcherMap.delete(matcherRef.record.name);\n                matcherRef.children.forEach(removeRoute);\n                matcherRef.alias.forEach(removeRoute);\n            }\n        }\n    }\n    function getRoutes() {\n        return matchers;\n    }\n    function insertMatcher(matcher) {\n        const index = findInsertionIndex(matcher, matchers);\n        matchers.splice(index, 0, matcher);\n        // only add the original record to the name map\n        if (matcher.record.name && !isAliasRecord(matcher))\n            matcherMap.set(matcher.record.name, matcher);\n    }\n    function resolve(location, currentLocation) {\n        let matcher;\n        let params = {};\n        let path;\n        let name;\n        if ('name' in location && location.name) {\n            matcher = matcherMap.get(location.name);\n            if (!matcher)\n                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n                    location,\n                });\n            name = matcher.record.name;\n            params = assign(\n            // paramsFromLocation is a new object\n            paramsFromLocation(currentLocation.params, \n            // only keep params that exist in the resolved location\n            // only keep optional params coming from a parent record\n            matcher.keys\n                .filter(k => !k.optional)\n                .concat(matcher.parent ? matcher.parent.keys.filter(k => k.optional) : [])\n                .map(k => k.name)), \n            // discard any existing params in the current location that do not exist here\n            // #1497 this ensures better active/exact matching\n            location.params &&\n                paramsFromLocation(location.params, matcher.keys.map(k => k.name)));\n            // throws if cannot be stringified\n            path = matcher.stringify(params);\n        }\n        else if (location.path != null) {\n            // no need to resolve the path with the matcher as it was provided\n            // this also allows the user to control the encoding\n            path = location.path;\n            matcher = matchers.find(m => m.re.test(path));\n            // matcher should have a value after the loop\n            if (matcher) {\n                // we know the matcher works because we tested the regexp\n                params = matcher.parse(path);\n                name = matcher.record.name;\n            }\n            // location is a relative path\n        }\n        else {\n            // match by name or path of current route\n            matcher = currentLocation.name\n                ? matcherMap.get(currentLocation.name)\n                : matchers.find(m => m.re.test(currentLocation.path));\n            if (!matcher)\n                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n                    location,\n                    currentLocation,\n                });\n            name = matcher.record.name;\n            // since we are navigating to the same location, we don't need to pick the\n            // params like when `name` is provided\n            params = assign({}, currentLocation.params, location.params);\n            path = matcher.stringify(params);\n        }\n        const matched = [];\n        let parentMatcher = matcher;\n        while (parentMatcher) {\n            // reversed order so parents are at the beginning\n            matched.unshift(parentMatcher.record);\n            parentMatcher = parentMatcher.parent;\n        }\n        return {\n            name,\n            path,\n            params,\n            matched,\n            meta: mergeMetaFields(matched),\n        };\n    }\n    // add initial routes\n    routes.forEach(route => addRoute(route));\n    function clearRoutes() {\n        matchers.length = 0;\n        matcherMap.clear();\n    }\n    return {\n        addRoute,\n        resolve,\n        removeRoute,\n        clearRoutes,\n        getRoutes,\n        getRecordMatcher,\n    };\n}\nfunction paramsFromLocation(params, keys) {\n    const newParams = {};\n    for (const key of keys) {\n        if (key in params)\n            newParams[key] = params[key];\n    }\n    return newParams;\n}\n/**\n * Normalizes a RouteRecordRaw. Creates a copy\n *\n * @param record\n * @returns the normalized version\n */\nfunction normalizeRouteRecord(record) {\n    const normalized = {\n        path: record.path,\n        redirect: record.redirect,\n        name: record.name,\n        meta: record.meta || {},\n        aliasOf: record.aliasOf,\n        beforeEnter: record.beforeEnter,\n        props: normalizeRecordProps(record),\n        children: record.children || [],\n        instances: {},\n        leaveGuards: new Set(),\n        updateGuards: new Set(),\n        enterCallbacks: {},\n        // must be declared afterwards\n        // mods: {},\n        components: 'components' in record\n            ? record.components || null\n            : record.component && { default: record.component },\n    };\n    // mods contain modules and shouldn't be copied,\n    // logged or anything. It's just used for internal\n    // advanced use cases like data loaders\n    Object.defineProperty(normalized, 'mods', {\n        value: {},\n    });\n    return normalized;\n}\n/**\n * Normalize the optional `props` in a record to always be an object similar to\n * components. Also accept a boolean for components.\n * @param record\n */\nfunction normalizeRecordProps(record) {\n    const propsObject = {};\n    // props does not exist on redirect records, but we can set false directly\n    const props = record.props || false;\n    if ('component' in record) {\n        propsObject.default = props;\n    }\n    else {\n        // NOTE: we could also allow a function to be applied to every component.\n        // Would need user feedback for use cases\n        for (const name in record.components)\n            propsObject[name] = typeof props === 'object' ? props[name] : props;\n    }\n    return propsObject;\n}\n/**\n * Checks if a record or any of its parent is an alias\n * @param record\n */\nfunction isAliasRecord(record) {\n    while (record) {\n        if (record.record.aliasOf)\n            return true;\n        record = record.parent;\n    }\n    return false;\n}\n/**\n * Merge meta fields of an array of records\n *\n * @param matched - array of matched records\n */\nfunction mergeMetaFields(matched) {\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n    const options = {};\n    for (const key in defaults) {\n        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n    }\n    return options;\n}\n/**\n * Performs a binary search to find the correct insertion index for a new matcher.\n *\n * Matchers are primarily sorted by their score. If scores are tied then we also consider parent/child relationships,\n * with descendants coming before ancestors. If there's still a tie, new routes are inserted after existing routes.\n *\n * @param matcher - new matcher to be inserted\n * @param matchers - existing matchers\n */\nfunction findInsertionIndex(matcher, matchers) {\n    // First phase: binary search based on score\n    let lower = 0;\n    let upper = matchers.length;\n    while (lower !== upper) {\n        const mid = (lower + upper) >> 1;\n        const sortOrder = comparePathParserScore(matcher, matchers[mid]);\n        if (sortOrder < 0) {\n            upper = mid;\n        }\n        else {\n            lower = mid + 1;\n        }\n    }\n    // Second phase: check for an ancestor with the same score\n    const insertionAncestor = getInsertionAncestor(matcher);\n    if (insertionAncestor) {\n        upper = matchers.lastIndexOf(insertionAncestor, upper - 1);\n    }\n    return upper;\n}\nfunction getInsertionAncestor(matcher) {\n    let ancestor = matcher;\n    while ((ancestor = ancestor.parent)) {\n        if (isMatchable(ancestor) &&\n            comparePathParserScore(matcher, ancestor) === 0) {\n            return ancestor;\n        }\n    }\n    return;\n}\n/**\n * Checks if a matcher can be reachable. This means if it's possible to reach it as a route. For example, routes without\n * a component, or name, or redirect, are just used to group other routes.\n * @param matcher\n * @param matcher.record record of the matcher\n * @returns\n */\nfunction isMatchable({ record }) {\n    return !!(record.name ||\n        (record.components && Object.keys(record.components).length) ||\n        record.redirect);\n}\n\n/**\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n * version with the leading `?` and without Should work as URLSearchParams\n\n * @internal\n *\n * @param search - search string to parse\n * @returns a query object\n */\nfunction parseQuery(search) {\n    const query = {};\n    // avoid creating an object with an empty key and empty value\n    // because of split('&')\n    if (search === '' || search === '?')\n        return query;\n    const hasLeadingIM = search[0] === '?';\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n    for (let i = 0; i < searchParams.length; ++i) {\n        // pre decode the + into space\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\n        // allow the = character\n        const eqPos = searchParam.indexOf('=');\n        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n        if (key in query) {\n            // an extra variable for ts types\n            let currentValue = query[key];\n            if (!isArray(currentValue)) {\n                currentValue = query[key] = [currentValue];\n            }\n            currentValue.push(value);\n        }\n        else {\n            query[key] = value;\n        }\n    }\n    return query;\n}\n/**\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n * doesn't prepend a `?`\n *\n * @internal\n *\n * @param query - query object to stringify\n * @returns string version of the query without the leading `?`\n */\nfunction stringifyQuery(query) {\n    let search = '';\n    for (let key in query) {\n        const value = query[key];\n        key = encodeQueryKey(key);\n        if (value == null) {\n            // only null adds the value\n            if (value !== undefined) {\n                search += (search.length ? '&' : '') + key;\n            }\n            continue;\n        }\n        // keep null values\n        const values = isArray(value)\n            ? value.map(v => v && encodeQueryValue(v))\n            : [value && encodeQueryValue(value)];\n        values.forEach(value => {\n            // skip undefined values in arrays as if they were not present\n            // smaller code than using filter\n            if (value !== undefined) {\n                // only append & with non-empty search\n                search += (search.length ? '&' : '') + key;\n                if (value != null)\n                    search += '=' + value;\n            }\n        });\n    }\n    return search;\n}\n/**\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n * numbers into strings, removing keys with an undefined value and replacing\n * undefined with null in arrays\n *\n * @param query - query object to normalize\n * @returns a normalized query object\n */\nfunction normalizeQuery(query) {\n    const normalizedQuery = {};\n    for (const key in query) {\n        const value = query[key];\n        if (value !== undefined) {\n            normalizedQuery[key] = isArray(value)\n                ? value.map(v => (v == null ? null : '' + v))\n                : value == null\n                    ? value\n                    : '' + value;\n        }\n    }\n    return normalizedQuery;\n}\n\n/**\n * RouteRecord being rendered by the closest ancestor Router View. Used for\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n * Location Matched\n *\n * @internal\n */\nconst matchedRouteKey = Symbol('');\n/**\n * Allows overriding the router view depth to control which component in\n * `matched` is rendered. rvd stands for Router View Depth\n *\n * @internal\n */\nconst viewDepthKey = Symbol('');\n/**\n * Allows overriding the router instance returned by `useRouter` in tests. r\n * stands for router\n *\n * @internal\n */\nconst routerKey = Symbol('');\n/**\n * Allows overriding the current route returned by `useRoute` in tests. rl\n * stands for route location\n *\n * @internal\n */\nconst routeLocationKey = Symbol('');\n/**\n * Allows overriding the current route used by router-view. Internally this is\n * used when the `route` prop is passed.\n *\n * @internal\n */\nconst routerViewLocationKey = Symbol('');\n\n/**\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n */\nfunction useCallbacks() {\n    let handlers = [];\n    function add(handler) {\n        handlers.push(handler);\n        return () => {\n            const i = handlers.indexOf(handler);\n            if (i > -1)\n                handlers.splice(i, 1);\n        };\n    }\n    function reset() {\n        handlers = [];\n    }\n    return {\n        add,\n        list: () => handlers.slice(),\n        reset,\n    };\n}\n\nfunction registerGuard(record, name, guard) {\n    const removeFromList = () => {\n        record[name].delete(guard);\n    };\n    vue.onUnmounted(removeFromList);\n    vue.onDeactivated(removeFromList);\n    vue.onActivated(() => {\n        record[name].add(guard);\n    });\n    record[name].add(guard);\n}\n/**\n * Add a navigation guard that triggers whenever the component for the current\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\n * used in any component. The guard is removed when the component is unmounted.\n *\n * @param leaveGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n    const activeRecord = vue.inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        return;\n    }\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\n * Add a navigation guard that triggers whenever the current location is about\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n * component. The guard is removed when the component is unmounted.\n *\n * @param updateGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n    const activeRecord = vue.inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        return;\n    }\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name, runWithContext = fn => fn()) {\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n    const enterCallbackArray = record &&\n        // name is defined if record is because of the function overload\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n    return () => new Promise((resolve, reject) => {\n        const next = (valid) => {\n            if (valid === false) {\n                reject(createRouterError(4 /* ErrorTypes.NAVIGATION_ABORTED */, {\n                    from,\n                    to,\n                }));\n            }\n            else if (valid instanceof Error) {\n                reject(valid);\n            }\n            else if (isRouteLocation(valid)) {\n                reject(createRouterError(2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */, {\n                    from: to,\n                    to: valid,\n                }));\n            }\n            else {\n                if (enterCallbackArray &&\n                    // since enterCallbackArray is truthy, both record and name also are\n                    record.enterCallbacks[name] === enterCallbackArray &&\n                    typeof valid === 'function') {\n                    enterCallbackArray.push(valid);\n                }\n                resolve();\n            }\n        };\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\n        const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));\n        let guardCall = Promise.resolve(guardReturn);\n        if (guard.length < 3)\n            guardCall = guardCall.then(next);\n        guardCall.catch(err => reject(err));\n    });\n}\nfunction extractComponentsGuards(matched, guardType, to, from, runWithContext = fn => fn()) {\n    const guards = [];\n    for (const record of matched) {\n        for (const name in record.components) {\n            let rawComponent = record.components[name];\n            // skip update and leave guards if the route component is not mounted\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\n                continue;\n            if (isRouteComponent(rawComponent)) {\n                // __vccOpts is added by vue-class-component and contain the regular options\n                const options = rawComponent.__vccOpts || rawComponent;\n                const guard = options[guardType];\n                guard &&\n                    guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));\n            }\n            else {\n                // start requesting the chunk already\n                let componentPromise = rawComponent();\n                guards.push(() => componentPromise.then(resolved => {\n                    if (!resolved)\n                        throw new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`);\n                    const resolvedComponent = isESModule(resolved)\n                        ? resolved.default\n                        : resolved;\n                    // keep the resolved module for plugins like data loaders\n                    record.mods[name] = resolved;\n                    // replace the function with the resolved component\n                    // cannot be null or undefined because we went into the for loop\n                    record.components[name] = resolvedComponent;\n                    // __vccOpts is added by vue-class-component and contain the regular options\n                    const options = resolvedComponent.__vccOpts || resolvedComponent;\n                    const guard = options[guardType];\n                    return (guard &&\n                        guardToPromiseFn(guard, to, from, record, name, runWithContext)());\n                }));\n            }\n        }\n    }\n    return guards;\n}\n/**\n * Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.\n *\n * @param route - resolved route to load\n */\nfunction loadRouteLocation(route) {\n    return route.matched.every(record => record.redirect)\n        ? Promise.reject(new Error('Cannot load a route that redirects.'))\n        : Promise.all(route.matched.map(record => record.components &&\n            Promise.all(Object.keys(record.components).reduce((promises, name) => {\n                const rawComponent = record.components[name];\n                if (typeof rawComponent === 'function' &&\n                    !('displayName' in rawComponent)) {\n                    promises.push(rawComponent().then(resolved => {\n                        if (!resolved)\n                            return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n                        const resolvedComponent = isESModule(resolved)\n                            ? resolved.default\n                            : resolved;\n                        // keep the resolved module for plugins like data loaders\n                        record.mods[name] = resolved;\n                        // replace the function with the resolved component\n                        // cannot be null or undefined because we went into the for loop\n                        record.components[name] = resolvedComponent;\n                        return;\n                    }));\n                }\n                return promises;\n            }, [])))).then(() => route);\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\n/**\n * Returns the internal behavior of a {@link RouterLink} without the rendering part.\n *\n * @param props - a `to` location and an optional `replace` flag\n */\nfunction useLink(props) {\n    const router = vue.inject(routerKey);\n    const currentRoute = vue.inject(routeLocationKey);\n    const route = vue.computed(() => {\n        const to = vue.unref(props.to);\n        return router.resolve(to);\n    });\n    const activeRecordIndex = vue.computed(() => {\n        const { matched } = route.value;\n        const { length } = matched;\n        const routeMatched = matched[length - 1];\n        const currentMatched = currentRoute.matched;\n        if (!routeMatched || !currentMatched.length)\n            return -1;\n        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n        if (index > -1)\n            return index;\n        // possible parent record\n        const parentRecordPath = getOriginalPath(matched[length - 2]);\n        return (\n        // we are dealing with nested routes\n        length > 1 &&\n            // if the parent and matched route have the same path, this link is\n            // referring to the empty child. Or we currently are on a different\n            // child of the same parent\n            getOriginalPath(routeMatched) === parentRecordPath &&\n            // avoid comparing the child with its parent\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\n            : index);\n    });\n    const isActive = vue.computed(() => activeRecordIndex.value > -1 &&\n        includesParams(currentRoute.params, route.value.params));\n    const isExactActive = vue.computed(() => activeRecordIndex.value > -1 &&\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\n    function navigate(e = {}) {\n        if (guardEvent(e)) {\n            const p = router[vue.unref(props.replace) ? 'replace' : 'push'](vue.unref(props.to)\n            // avoid uncaught errors are they are logged anyway\n            ).catch(noop);\n            if (props.viewTransition &&\n                typeof document !== 'undefined' &&\n                'startViewTransition' in document) {\n                document.startViewTransition(() => p);\n            }\n            return p;\n        }\n        return Promise.resolve();\n    }\n    /**\n     * NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this\n     */\n    return {\n        route,\n        href: vue.computed(() => route.value.href),\n        isActive,\n        isExactActive,\n        navigate,\n    };\n}\nfunction preferSingleVNode(vnodes) {\n    return vnodes.length === 1 ? vnodes[0] : vnodes;\n}\nconst RouterLinkImpl = /*#__PURE__*/ vue.defineComponent({\n    name: 'RouterLink',\n    compatConfig: { MODE: 3 },\n    props: {\n        to: {\n            type: [String, Object],\n            required: true,\n        },\n        replace: Boolean,\n        activeClass: String,\n        // inactiveClass: String,\n        exactActiveClass: String,\n        custom: Boolean,\n        ariaCurrentValue: {\n            type: String,\n            default: 'page',\n        },\n    },\n    useLink,\n    setup(props, { slots }) {\n        const link = vue.reactive(useLink(props));\n        const { options } = vue.inject(routerKey);\n        const elClass = vue.computed(() => ({\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n            // [getLinkClass(\n            //   props.inactiveClass,\n            //   options.linkInactiveClass,\n            //   'router-link-inactive'\n            // )]: !link.isExactActive,\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\n        }));\n        return () => {\n            const children = slots.default && preferSingleVNode(slots.default(link));\n            return props.custom\n                ? children\n                : vue.h('a', {\n                    'aria-current': link.isExactActive\n                        ? props.ariaCurrentValue\n                        : null,\n                    href: link.href,\n                    // this would override user added attrs but Vue will still add\n                    // the listener, so we end up triggering both\n                    onClick: link.navigate,\n                    class: elClass.value,\n                }, children);\n        };\n    },\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a link that triggers a navigation on click.\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n    // don't redirect with control keys\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n        return;\n    // don't redirect when preventDefault called\n    if (e.defaultPrevented)\n        return;\n    // don't redirect on right click\n    if (e.button !== undefined && e.button !== 0)\n        return;\n    // don't redirect if `target=\"_blank\"`\n    // @ts-expect-error getAttribute does exist\n    if (e.currentTarget && e.currentTarget.getAttribute) {\n        // @ts-expect-error getAttribute exists\n        const target = e.currentTarget.getAttribute('target');\n        if (/\\b_blank\\b/i.test(target))\n            return;\n    }\n    // this may be a Weex event which doesn't have this method\n    if (e.preventDefault)\n        e.preventDefault();\n    return true;\n}\nfunction includesParams(outer, inner) {\n    for (const key in inner) {\n        const innerValue = inner[key];\n        const outerValue = outer[key];\n        if (typeof innerValue === 'string') {\n            if (innerValue !== outerValue)\n                return false;\n        }\n        else {\n            if (!isArray(outerValue) ||\n                outerValue.length !== innerValue.length ||\n                innerValue.some((value, i) => value !== outerValue[i]))\n                return false;\n        }\n    }\n    return true;\n}\n/**\n * Get the original path value of a record by following its aliasOf\n * @param record\n */\nfunction getOriginalPath(record) {\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\n}\n/**\n * Utility class to get the active class based on defaults.\n * @param propClass\n * @param globalClass\n * @param defaultClass\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\n    ? propClass\n    : globalClass != null\n        ? globalClass\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ vue.defineComponent({\n    name: 'RouterView',\n    // #674 we manually inherit them\n    inheritAttrs: false,\n    props: {\n        name: {\n            type: String,\n            default: 'default',\n        },\n        route: Object,\n    },\n    // Better compat for @vue/compat users\n    // https://github.com/vuejs/router/issues/1315\n    compatConfig: { MODE: 3 },\n    setup(props, { attrs, slots }) {\n        const injectedRoute = vue.inject(routerViewLocationKey);\n        const routeToDisplay = vue.computed(() => props.route || injectedRoute.value);\n        const injectedDepth = vue.inject(viewDepthKey, 0);\n        // The depth changes based on empty components option, which allows passthrough routes e.g. routes with children\n        // that are used to reuse the `path` property\n        const depth = vue.computed(() => {\n            let initialDepth = vue.unref(injectedDepth);\n            const { matched } = routeToDisplay.value;\n            let matchedRoute;\n            while ((matchedRoute = matched[initialDepth]) &&\n                !matchedRoute.components) {\n                initialDepth++;\n            }\n            return initialDepth;\n        });\n        const matchedRouteRef = vue.computed(() => routeToDisplay.value.matched[depth.value]);\n        vue.provide(viewDepthKey, vue.computed(() => depth.value + 1));\n        vue.provide(matchedRouteKey, matchedRouteRef);\n        vue.provide(routerViewLocationKey, routeToDisplay);\n        const viewRef = vue.ref();\n        // watch at the same time the component instance, the route record we are\n        // rendering, and the name\n        vue.watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n            // copy reused instances\n            if (to) {\n                // this will update the instance for new instances as well as reused\n                // instances when navigating to a new route\n                to.instances[name] = instance;\n                // the component instance is reused for a different route or name, so\n                // we copy any saved update or leave guards. With async setup, the\n                // mounting component will mount before the matchedRoute changes,\n                // making instance === oldInstance, so we check if guards have been\n                // added before. This works because we remove guards when\n                // unmounting/deactivating components\n                if (from && from !== to && instance && instance === oldInstance) {\n                    if (!to.leaveGuards.size) {\n                        to.leaveGuards = from.leaveGuards;\n                    }\n                    if (!to.updateGuards.size) {\n                        to.updateGuards = from.updateGuards;\n                    }\n                }\n            }\n            // trigger beforeRouteEnter next callbacks\n            if (instance &&\n                to &&\n                // if there is no instance but to and from are the same this might be\n                // the first visit\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n            }\n        }, { flush: 'post' });\n        return () => {\n            const route = routeToDisplay.value;\n            // we need the value at the time we render because when we unmount, we\n            // navigated to a different location so the value is different\n            const currentName = props.name;\n            const matchedRoute = matchedRouteRef.value;\n            const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n            if (!ViewComponent) {\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\n            }\n            // props from route configuration\n            const routePropsOption = matchedRoute.props[currentName];\n            const routeProps = routePropsOption\n                ? routePropsOption === true\n                    ? route.params\n                    : typeof routePropsOption === 'function'\n                        ? routePropsOption(route)\n                        : routePropsOption\n                : null;\n            const onVnodeUnmounted = vnode => {\n                // remove the instance reference to prevent leak\n                if (vnode.component.isUnmounted) {\n                    matchedRoute.instances[currentName] = null;\n                }\n            };\n            const component = vue.h(ViewComponent, assign({}, routeProps, attrs, {\n                onVnodeUnmounted,\n                ref: viewRef,\n            }));\n            return (\n            // pass the vnode to the slot as a prop.\n            // h and <component :is=\"...\"> both accept vnodes\n            normalizeSlot(slots.default, { Component: component, route }) ||\n                component);\n        };\n    },\n});\nfunction normalizeSlot(slot, data) {\n    if (!slot)\n        return null;\n    const slotContent = slot(data);\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to display the current route the user is at.\n */\nconst RouterView = RouterViewImpl;\n\n/**\n * Creates a Router instance that can be used by a Vue app.\n *\n * @param options - {@link RouterOptions}\n */\nfunction createRouter(options) {\n    const matcher = createRouterMatcher(options.routes, options);\n    const parseQuery$1 = options.parseQuery || parseQuery;\n    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n    const routerHistory = options.history;\n    const beforeGuards = useCallbacks();\n    const beforeResolveGuards = useCallbacks();\n    const afterGuards = useCallbacks();\n    const currentRoute = vue.shallowRef(START_LOCATION_NORMALIZED);\n    let pendingLocation = START_LOCATION_NORMALIZED;\n    // leave the scrollRestoration if no scrollBehavior is provided\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n        history.scrollRestoration = 'manual';\n    }\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n    const encodeParams = applyToParams.bind(null, encodeParam);\n    const decodeParams = \n    // @ts-expect-error: intentionally avoid the type check\n    applyToParams.bind(null, decode);\n    function addRoute(parentOrRoute, route) {\n        let parent;\n        let record;\n        if (isRouteName(parentOrRoute)) {\n            parent = matcher.getRecordMatcher(parentOrRoute);\n            record = route;\n        }\n        else {\n            record = parentOrRoute;\n        }\n        return matcher.addRoute(record, parent);\n    }\n    function removeRoute(name) {\n        const recordMatcher = matcher.getRecordMatcher(name);\n        if (recordMatcher) {\n            matcher.removeRoute(recordMatcher);\n        }\n    }\n    function getRoutes() {\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n    }\n    function hasRoute(name) {\n        return !!matcher.getRecordMatcher(name);\n    }\n    function resolve(rawLocation, currentLocation) {\n        // const resolve: Router['resolve'] = (rawLocation: RouteLocationRaw, currentLocation) => {\n        // const objectLocation = routerLocationAsObject(rawLocation)\n        // we create a copy to modify it later\n        currentLocation = assign({}, currentLocation || currentRoute.value);\n        if (typeof rawLocation === 'string') {\n            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n            const href = routerHistory.createHref(locationNormalized.fullPath);\n            // locationNormalized is always a new object\n            return assign(locationNormalized, matchedRoute, {\n                params: decodeParams(matchedRoute.params),\n                hash: decode(locationNormalized.hash),\n                redirectedFrom: undefined,\n                href,\n            });\n        }\n        let matcherLocation;\n        // path could be relative in object as well\n        if (rawLocation.path != null) {\n            matcherLocation = assign({}, rawLocation, {\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\n            });\n        }\n        else {\n            // remove any nullish param\n            const targetParams = assign({}, rawLocation.params);\n            for (const key in targetParams) {\n                if (targetParams[key] == null) {\n                    delete targetParams[key];\n                }\n            }\n            // pass encoded values to the matcher, so it can produce encoded path and fullPath\n            matcherLocation = assign({}, rawLocation, {\n                params: encodeParams(targetParams),\n            });\n            // current location params are decoded, we need to encode them in case the\n            // matcher merges the params\n            currentLocation.params = encodeParams(currentLocation.params);\n        }\n        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n        const hash = rawLocation.hash || '';\n        // the matcher might have merged current location params, so\n        // we need to run the decoding again\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n            hash: encodeHash(hash),\n            path: matchedRoute.path,\n        }));\n        const href = routerHistory.createHref(fullPath);\n        return assign({\n            fullPath,\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\n            // hash\n            hash,\n            query: \n            // if the user is using a custom query lib like qs, we might have\n            // nested objects, so we keep the query as is, meaning it can contain\n            // numbers at `$route.query`, but at the point, the user will have to\n            // use their own type anyway.\n            // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n            stringifyQuery$1 === stringifyQuery\n                ? normalizeQuery(rawLocation.query)\n                : (rawLocation.query || {}),\n        }, matchedRoute, {\n            redirectedFrom: undefined,\n            href,\n        });\n    }\n    function locationAsObject(to) {\n        return typeof to === 'string'\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\n            : assign({}, to);\n    }\n    function checkCanceledNavigation(to, from) {\n        if (pendingLocation !== to) {\n            return createRouterError(8 /* ErrorTypes.NAVIGATION_CANCELLED */, {\n                from,\n                to,\n            });\n        }\n    }\n    function push(to) {\n        return pushWithRedirect(to);\n    }\n    function replace(to) {\n        return push(assign(locationAsObject(to), { replace: true }));\n    }\n    function handleRedirectRecord(to) {\n        const lastMatched = to.matched[to.matched.length - 1];\n        if (lastMatched && lastMatched.redirect) {\n            const { redirect } = lastMatched;\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n            if (typeof newTargetLocation === 'string') {\n                newTargetLocation =\n                    newTargetLocation.includes('?') || newTargetLocation.includes('#')\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\n                        : // force empty params\n                            { path: newTargetLocation };\n                // @ts-expect-error: force empty params when a string is passed to let\n                // the router parse them again\n                newTargetLocation.params = {};\n            }\n            return assign({\n                query: to.query,\n                hash: to.hash,\n                // avoid transferring params if the redirect has a path\n                params: newTargetLocation.path != null ? {} : to.params,\n            }, newTargetLocation);\n        }\n    }\n    function pushWithRedirect(to, redirectedFrom) {\n        const targetLocation = (pendingLocation = resolve(to));\n        const from = currentRoute.value;\n        const data = to.state;\n        const force = to.force;\n        // to could be a string where `replace` is a function\n        const replace = to.replace === true;\n        const shouldRedirect = handleRedirectRecord(targetLocation);\n        if (shouldRedirect)\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n                state: typeof shouldRedirect === 'object'\n                    ? assign({}, data, shouldRedirect.state)\n                    : data,\n                force,\n                replace,\n            }), \n            // keep original redirectedFrom if it exists\n            redirectedFrom || targetLocation);\n        // if it was a redirect we already called `pushWithRedirect` above\n        const toLocation = targetLocation;\n        toLocation.redirectedFrom = redirectedFrom;\n        let failure;\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n            failure = createRouterError(16 /* ErrorTypes.NAVIGATION_DUPLICATED */, { to: toLocation, from });\n            // trigger scroll to allow scrolling to the same anchor\n            handleScroll(from, from, \n            // this is a push, the only way for it to be triggered from a\n            // history.listen is with a redirect, which makes it become a push\n            true, \n            // This cannot be the first navigation because the initial location\n            // cannot be manually navigated to\n            false);\n        }\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\n            .catch((error) => isNavigationFailure(error)\n            ? // navigation redirects still mark the router as ready\n                isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)\n                    ? error\n                    : markAsReady(error) // also returns the error\n            : // reject any unknown error\n                triggerError(error, toLocation, from))\n            .then((failure) => {\n            if (failure) {\n                if (isNavigationFailure(failure, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n                    return pushWithRedirect(\n                    // keep options\n                    assign({\n                        // preserve an existing replacement but allow the redirect to override it\n                        replace,\n                    }, locationAsObject(failure.to), {\n                        state: typeof failure.to === 'object'\n                            ? assign({}, data, failure.to.state)\n                            : data,\n                        force,\n                    }), \n                    // preserve the original redirectedFrom if any\n                    redirectedFrom || toLocation);\n                }\n            }\n            else {\n                // if we fail we don't finalize the navigation\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\n            }\n            triggerAfterEach(toLocation, from, failure);\n            return failure;\n        });\n    }\n    /**\n     * Helper to reject and skip all navigation guards if a new navigation happened\n     * @param to\n     * @param from\n     */\n    function checkCanceledNavigationAndReject(to, from) {\n        const error = checkCanceledNavigation(to, from);\n        return error ? Promise.reject(error) : Promise.resolve();\n    }\n    function runWithContext(fn) {\n        const app = installedApps.values().next().value;\n        // support Vue < 3.3\n        return app && typeof app.runWithContext === 'function'\n            ? app.runWithContext(fn)\n            : fn();\n    }\n    // TODO: refactor the whole before guards by internally using router.beforeEach\n    function navigate(to, from) {\n        let guards;\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n        // all components here have been resolved once because we are leaving\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\n        // leavingRecords is already reversed\n        for (const record of leavingRecords) {\n            record.leaveGuards.forEach(guard => {\n                guards.push(guardToPromiseFn(guard, to, from));\n            });\n        }\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n        guards.push(canceledNavigationCheck);\n        // run the queue of per route beforeRouteLeave guards\n        return (runGuardQueue(guards)\n            .then(() => {\n            // check global guards beforeEach\n            guards = [];\n            for (const guard of beforeGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check in components beforeRouteUpdate\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n            for (const record of updatingRecords) {\n                record.updateGuards.forEach(guard => {\n                    guards.push(guardToPromiseFn(guard, to, from));\n                });\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check the route beforeEnter\n            guards = [];\n            for (const record of enteringRecords) {\n                // do not trigger beforeEnter on reused views\n                if (record.beforeEnter) {\n                    if (isArray(record.beforeEnter)) {\n                        for (const beforeEnter of record.beforeEnter)\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\n                    }\n                    else {\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n                    }\n                }\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\n            to.matched.forEach(record => (record.enterCallbacks = {}));\n            // check in-component beforeRouteEnter\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from, runWithContext);\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check global guards beforeResolve\n            guards = [];\n            for (const guard of beforeResolveGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            // catch any navigation canceled\n            .catch(err => isNavigationFailure(err, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)\n            ? err\n            : Promise.reject(err)));\n    }\n    function triggerAfterEach(to, from, failure) {\n        // navigation is confirmed, call afterGuards\n        // TODO: wrap with error handlers\n        afterGuards\n            .list()\n            .forEach(guard => runWithContext(() => guard(to, from, failure)));\n    }\n    /**\n     * - Cleans up any navigation guards\n     * - Changes the url if necessary\n     * - Calls the scrollBehavior\n     */\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\n        // a more recent navigation took place\n        const error = checkCanceledNavigation(toLocation, from);\n        if (error)\n            return error;\n        // only consider as push if it's not the first navigation\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n        const state = !isBrowser ? {} : history.state;\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\n        // it's just reflecting the url\n        if (isPush) {\n            // on the initial navigation, we want to reuse the scroll position from\n            // history state if it exists\n            if (replace || isFirstNavigation)\n                routerHistory.replace(toLocation.fullPath, assign({\n                    scroll: isFirstNavigation && state && state.scroll,\n                }, data));\n            else\n                routerHistory.push(toLocation.fullPath, data);\n        }\n        // accept current navigation\n        currentRoute.value = toLocation;\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\n        markAsReady();\n    }\n    let removeHistoryListener;\n    // attach listener to history to trigger navigations\n    function setupListeners() {\n        // avoid setting up listeners twice due to an invalid first navigation\n        if (removeHistoryListener)\n            return;\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\n            if (!router.listening)\n                return;\n            // cannot be a redirect route because it was in history\n            const toLocation = resolve(to);\n            // due to dynamic routing, and to hash history with manual navigation\n            // (manually changing the url or calling history.hash = '#/somewhere'),\n            // there could be a redirect record in history\n            const shouldRedirect = handleRedirectRecord(toLocation);\n            if (shouldRedirect) {\n                pushWithRedirect(assign(shouldRedirect, { replace: true, force: true }), toLocation).catch(noop);\n                return;\n            }\n            pendingLocation = toLocation;\n            const from = currentRoute.value;\n            // TODO: should be moved to web history?\n            if (isBrowser) {\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n            }\n            navigate(toLocation, from)\n                .catch((error) => {\n                if (isNavigationFailure(error, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n                    return error;\n                }\n                if (isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\n                    // false) but this is bug prone as we have no way to wait the\n                    // navigation to be finished before calling pushWithRedirect. Using\n                    // a setTimeout of 16ms seems to work but there is no guarantee for\n                    // it to work on every browser. So instead we do not restore the\n                    // history entry and trigger a new navigation as requested by the\n                    // navigation guard.\n                    // the error is already handled by router.push we just want to avoid\n                    // logging the error\n                    pushWithRedirect(assign(locationAsObject(error.to), {\n                        force: true,\n                    }), toLocation\n                    // avoid an uncaught rejection, let push call triggerError\n                    )\n                        .then(failure => {\n                        // manual change in hash history #916 ending up in the URL not\n                        // changing, but it was changed by the manual url change, so we\n                        // need to manually change it ourselves\n                        if (isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ |\n                            16 /* ErrorTypes.NAVIGATION_DUPLICATED */) &&\n                            !info.delta &&\n                            info.type === NavigationType.pop) {\n                            routerHistory.go(-1, false);\n                        }\n                    })\n                        .catch(noop);\n                    // avoid the then branch\n                    return Promise.reject();\n                }\n                // do not restore history on unknown direction\n                if (info.delta) {\n                    routerHistory.go(-info.delta, false);\n                }\n                // unrecognized error, transfer to the global handler\n                return triggerError(error, toLocation, from);\n            })\n                .then((failure) => {\n                failure =\n                    failure ||\n                        finalizeNavigation(\n                        // after navigation, all matched components are resolved\n                        toLocation, from, false);\n                // revert the navigation\n                if (failure) {\n                    if (info.delta &&\n                        // a new navigation has been triggered, so we do not want to revert, that will change the current history\n                        // entry while a different route is displayed\n                        !isNavigationFailure(failure, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n                        routerHistory.go(-info.delta, false);\n                    }\n                    else if (info.type === NavigationType.pop &&\n                        isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 16 /* ErrorTypes.NAVIGATION_DUPLICATED */)) {\n                        // manual change in hash history #916\n                        // it's like a push but lacks the information of the direction\n                        routerHistory.go(-1, false);\n                    }\n                }\n                triggerAfterEach(toLocation, from, failure);\n            })\n                // avoid warnings in the console about uncaught rejections, they are logged by triggerErrors\n                .catch(noop);\n        });\n    }\n    // Initialization and Errors\n    let readyHandlers = useCallbacks();\n    let errorListeners = useCallbacks();\n    let ready;\n    /**\n     * Trigger errorListeners added via onError and throws the error as well\n     *\n     * @param error - error to throw\n     * @param to - location we were navigating to when the error happened\n     * @param from - location we were navigating from when the error happened\n     * @returns the error as a rejected promise\n     */\n    function triggerError(error, to, from) {\n        markAsReady(error);\n        const list = errorListeners.list();\n        if (list.length) {\n            list.forEach(handler => handler(error, to, from));\n        }\n        else {\n            console.error(error);\n        }\n        // reject the error no matter there were error listeners or not\n        return Promise.reject(error);\n    }\n    function isReady() {\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\n            return Promise.resolve();\n        return new Promise((resolve, reject) => {\n            readyHandlers.add([resolve, reject]);\n        });\n    }\n    function markAsReady(err) {\n        if (!ready) {\n            // still not ready if an error happened\n            ready = !err;\n            setupListeners();\n            readyHandlers\n                .list()\n                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\n            readyHandlers.reset();\n        }\n        return err;\n    }\n    // Scroll behavior\n    function handleScroll(to, from, isPush, isFirstNavigation) {\n        const { scrollBehavior } = options;\n        if (!isBrowser || !scrollBehavior)\n            return Promise.resolve();\n        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\n            ((isFirstNavigation || !isPush) &&\n                history.state &&\n                history.state.scroll) ||\n            null;\n        return vue.nextTick()\n            .then(() => scrollBehavior(to, from, scrollPosition))\n            .then(position => position && scrollToPosition(position))\n            .catch(err => triggerError(err, to, from));\n    }\n    const go = (delta) => routerHistory.go(delta);\n    let started;\n    const installedApps = new Set();\n    const router = {\n        currentRoute,\n        listening: true,\n        addRoute,\n        removeRoute,\n        clearRoutes: matcher.clearRoutes,\n        hasRoute,\n        getRoutes,\n        resolve,\n        options,\n        push,\n        replace,\n        go,\n        back: () => go(-1),\n        forward: () => go(1),\n        beforeEach: beforeGuards.add,\n        beforeResolve: beforeResolveGuards.add,\n        afterEach: afterGuards.add,\n        onError: errorListeners.add,\n        isReady,\n        install(app) {\n            const router = this;\n            app.component('RouterLink', RouterLink);\n            app.component('RouterView', RouterView);\n            app.config.globalProperties.$router = router;\n            Object.defineProperty(app.config.globalProperties, '$route', {\n                enumerable: true,\n                get: () => vue.unref(currentRoute),\n            });\n            // this initial navigation is only necessary on client, on server it doesn't\n            // make sense because it will create an extra unnecessary navigation and could\n            // lead to problems\n            if (isBrowser &&\n                // used for the initial navigation client side to avoid pushing\n                // multiple times when the router is used in multiple apps\n                !started &&\n                currentRoute.value === START_LOCATION_NORMALIZED) {\n                // see above\n                started = true;\n                push(routerHistory.location).catch(err => {\n                });\n            }\n            const reactiveRoute = {};\n            for (const key in START_LOCATION_NORMALIZED) {\n                Object.defineProperty(reactiveRoute, key, {\n                    get: () => currentRoute.value[key],\n                    enumerable: true,\n                });\n            }\n            app.provide(routerKey, router);\n            app.provide(routeLocationKey, vue.shallowReactive(reactiveRoute));\n            app.provide(routerViewLocationKey, currentRoute);\n            const unmountApp = app.unmount;\n            installedApps.add(app);\n            app.unmount = function () {\n                installedApps.delete(app);\n                // the router is not attached to an app anymore\n                if (installedApps.size < 1) {\n                    // invalidate the current navigation\n                    pendingLocation = START_LOCATION_NORMALIZED;\n                    removeHistoryListener && removeHistoryListener();\n                    removeHistoryListener = null;\n                    currentRoute.value = START_LOCATION_NORMALIZED;\n                    started = false;\n                    ready = false;\n                }\n                unmountApp();\n            };\n        },\n    };\n    // TODO: type this as NavigationGuardReturn or similar instead of any\n    function runGuardQueue(guards) {\n        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());\n    }\n    return router;\n}\nfunction extractChangingRecords(to, from) {\n    const leavingRecords = [];\n    const updatingRecords = [];\n    const enteringRecords = [];\n    const len = Math.max(from.matched.length, to.matched.length);\n    for (let i = 0; i < len; i++) {\n        const recordFrom = from.matched[i];\n        if (recordFrom) {\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\n                updatingRecords.push(recordFrom);\n            else\n                leavingRecords.push(recordFrom);\n        }\n        const recordTo = to.matched[i];\n        if (recordTo) {\n            // the type doesn't matter because we are comparing per reference\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n                enteringRecords.push(recordTo);\n            }\n        }\n    }\n    return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\n * Returns the router instance. Equivalent to using `$router` inside\n * templates.\n */\nfunction useRouter() {\n    return vue.inject(routerKey);\n}\n/**\n * Returns the current route location. Equivalent to using `$route` inside\n * templates.\n */\nfunction useRoute(_name) {\n    return vue.inject(routeLocationKey);\n}\n\nexports.RouterLink = RouterLink;\nexports.RouterView = RouterView;\nexports.START_LOCATION = START_LOCATION_NORMALIZED;\nexports.createMemoryHistory = createMemoryHistory;\nexports.createRouter = createRouter;\nexports.createRouterMatcher = createRouterMatcher;\nexports.createWebHashHistory = createWebHashHistory;\nexports.createWebHistory = createWebHistory;\nexports.isNavigationFailure = isNavigationFailure;\nexports.loadRouteLocation = loadRouteLocation;\nexports.matchedRouteKey = matchedRouteKey;\nexports.onBeforeRouteLeave = onBeforeRouteLeave;\nexports.onBeforeRouteUpdate = onBeforeRouteUpdate;\nexports.parseQuery = parseQuery;\nexports.routeLocationKey = routeLocationKey;\nexports.routerKey = routerKey;\nexports.routerViewLocationKey = routerViewLocationKey;\nexports.stringifyQuery = stringifyQuery;\nexports.useLink = useLink;\nexports.useRoute = useRoute;\nexports.useRouter = useRouter;\nexports.viewDepthKey = viewDepthKey;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/vue-router.prod.cjs')\n} else {\n  module.exports = require('./dist/vue-router.cjs')\n}\n"],"names":["vue","isBrowser","document","isRouteComponent","component","isESModule","obj","__esModule","Symbol","toStringTag","default","assign","Object","applyToParams","fn","params","newParams","key","value","isArray","map","noop","Array","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","text","encodeURI","replace","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","decodeURIComponent","err","TRAILING_SLASH_RE","removeTrailingSlash","path","parseURL","parseQuery","location","currentLocation","query","searchString","hash","hashPos","indexOf","searchPos","slice","length","resolveRelativePath","fullPath","stringifyURL","stringifyQuery","stripBase","pathname","base","toLowerCase","startsWith","isSameRouteLocation","a","b","aLastIndex","matched","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","aliasOf","keys","isSameRouteLocationParamsValue","isEquivalentArray","every","i","to","from","fromSegments","split","toSegments","lastToSegment","push","toPosition","segment","position","join","START_LOCATION_NORMALIZED","name","undefined","meta","redirectedFrom","NavigationType","NavigationDirection","START","normalizeBase","baseEl","querySelector","getAttribute","BEFORE_HASH_RE","createHref","getElementPosition","el","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","left","top","computeScrollPosition","window","scrollX","scrollY","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getElementById","style","scrollTo","getScrollKey","delta","history","state","scrollPositions","Map","saveScrollPosition","scrollPosition","set","getSavedScrollPosition","scroll","get","delete","createBaseLocation","protocol","host","createCurrentLocation","search","slicePos","includes","pathFromHash","useHistoryListeners","historyState","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","listener","type","pop","direction","forward","back","unknown","pauseListeners","listen","callback","teardown","index","splice","beforeUnloadListener","replaceState","destroy","removeEventListener","addEventListener","passive","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","console","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","defineProperty","enumerable","createMemoryHistory","queue","setLocation","info","shouldTrigger","this","Math","max","min","createWebHashHistory","isRouteLocation","route","isRouteName","NavigationFailureSymbol","exports","NavigationFailureType","ErrorTypeMessages","JSON","stringify","stringifyRoute","createRouterError","Error","isNavigationFailure","propertiesToLog","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","endsWith","parse","match","avoidDuplicatedSlash","param","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","abs","isLastScoreNegative","last","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","test","createRouteRecordMatcher","record","parent","parser","matcher","children","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","mergeOptions","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","isAliasRecord","removeRoute","isMatchable","insertMatcher","matcherRef","getRoutes","findInsertionIndex","resolve","paramsFromLocation","filter","k","concat","find","m","parentMatcher","unshift","mergeMetaFields","clearRoutes","clear","normalized","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","Set","updateGuards","enterCallbacks","propsObject","reduce","defaults","partialOptions","lower","upper","mid","sortOrder","insertionAncestor","getInsertionAncestor","lastIndexOf","ancestor","hasLeadingIM","searchParams","searchParam","eqPos","currentValue","values","v","normalizeQuery","normalizedQuery","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","useCallbacks","handlers","add","handler","reset","list","registerGuard","guard","removeFromList","onUnmounted","onDeactivated","onActivated","onBeforeRouteLeave","leaveGuard","activeRecord","inject","onBeforeRouteUpdate","updateGuard","guardToPromiseFn","runWithContext","enterCallbackArray","Promise","reject","next","valid","guardReturn","call","guardCall","then","catch","extractComponentsGuards","guardType","guards","rawComponent","__vccOpts","componentPromise","resolved","resolvedComponent","mods","loadRouteLocation","all","promises","useLink","router","currentRoute","computed","unref","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","e","guardEvent","p","viewTransition","startViewTransition","href","preferSingleVNode","vnodes","RouterLinkImpl","defineComponent","compatConfig","MODE","String","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","setup","slots","link","reactive","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","h","onClick","class","RouterLink","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","target","preventDefault","outer","inner","innerValue","outerValue","some","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","attrs","injectedRoute","routeToDisplay","injectedDepth","depth","initialDepth","matchedRoute","matchedRouteRef","provide","viewRef","ref","watch","instance","oldInstance","oldName","size","flush","currentName","ViewComponent","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","slot","slotContent","RouterView","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","shallowRef","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","matcherLocation","targetParams","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","failure","handleScroll","markAsReady","triggerError","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","app","installedApps","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","setupListeners","_from","listening","ready","readyHandlers","errorListeners","isReady","nextTick","started","beforeEach","beforeResolve","afterEach","onError","install","config","globalProperties","$router","reactiveRoute","shallowReactive","unmountApp","unmount","promise","len","recordFrom","recordTo","useRouter","useRoute","_name","module"],"sourceRoot":""}